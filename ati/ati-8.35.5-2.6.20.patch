-- firegl_public.c-orig    2007-02-21 19:56:45.000000000 -0500
+++ firegl_public.c    2007-02-25 12:31:59.000000000 -0500
@@ -119,6 +119,7 @@
 
 #include <linux/interrupt.h>
 #include <linux/delay.h>
+#include <linux/freezer.h>
 #include <linux/console.h>
 
 //#include <linux/signal.h>
@@ -204,6 +205,70 @@
 int errno;
 #endif // __ia64__
 
+#if defined(__i386__)
+#define __syscall_return(type, res) \
+do { \
+        if ((unsigned long)(res) >= (unsigned long)(-(128 + 1))) { \
+                errno = -(res); \
+                res = -1; \
+        } \
+        return (type) (res); \
+} while (0)
+#define _syscall2(type,name,type1,arg1,type2,arg2) \
+type name(type1 arg1,type2 arg2) \
+{ \
+long __res; \
+__asm__ volatile ("push %%ebx ; movl %2,%%ebx ; int $0x80 ; pop %%ebx" \
+        : "=a" (__res) \
+        : "0" (__NR_##name),"ri" ((long)(arg1)),"c" ((long)(arg2)) \
+        : "memory"); \
+__syscall_return(type,__res); \
+}
+
+#define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3) \
+type name(type1 arg1,type2 arg2,type3 arg3) \
+{ \
+long __res; \
+__asm__ volatile ("push %%ebx ; movl %2,%%ebx ; int $0x80 ; pop %%ebx" \
+        : "=a" (__res) \
+        : "0" (__NR_##name),"ri" ((long)(arg1)),"c" ((long)(arg2)), \
+                  "d" ((long)(arg3)) : "memory"); \
+__syscall_return(type,__res); \
+}
+#elif defined(__x86_64__)
+#define __syscall_clobber "r11","rcx","memory" 
+#define __syscall "syscall"
+
+#define __syscall_return(type, res) \
+do { \
+        if ((unsigned long)(res) >= (unsigned long)(-127)) { \
+                errno = -(res); \
+                res = -1; \
+        } \
+        return (type) (res); \
+} while (0)
+#define _syscall2(type,name,type1,arg1,type2,arg2) \
+type name(type1 arg1,type2 arg2) \
+{ \
+long __res; \
+__asm__ volatile (__syscall \
+        : "=a" (__res) \
+        : "0" (__NR_##name),"D" ((long)(arg1)),"S" ((long)(arg2)) : __syscall_clobber ); \
+__syscall_return(type,__res); \
+}
+
+#define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3) \
+type name(type1 arg1,type2 arg2,type3 arg3) \
+{ \
+long __res; \
+__asm__ volatile (__syscall \
+        : "=a" (__res) \
+        : "0" (__NR_##name),"D" ((long)(arg1)),"S" ((long)(arg2)), \
+                  "d" ((long)(arg3)) : __syscall_clobber); \
+__syscall_return(type,__res); \
+}
+#endif
+
 // int mlock(const void *addr, size_t len);
 _syscall2(int, mlock, const void *, addr, size_t, len )
 // int munlock(const void *addr, size_t len);
@@ -4341,24 +4406,6 @@
 #endif
 }
 
-/** \brief Freeze the thread if kernel requested so because of going to suspend
- *
- * \return Nonzero if freeze has been performed, zero otherwise
- *
- */
-unsigned int kas_try_to_freeze(void)
-{
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,10)
-    return 0;
-#else
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,12)
-    return try_to_freeze(PF_FREEZE);
-#else
-    return try_to_freeze();
-#endif
-#endif
-}
-
 /** \brief Storage for execution level(s) */
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 /* SMP support for 2.6.0 and higher */
@@ -4985,28 +5032,13 @@
     unsigned int ret = 0;
     kasSlabCache_t* slabcache_obj = (kasSlabCache_t*)hSlabCache;
 
-    DBG_ENTER("0x%08X", hSlabCache);
-
-    if (!(slabcache_obj->cache))
-    {
-        DBG_ERROR("slab object '%s' is not initialized");
-        DBG_LEAVE("0");
-        return 0;
-    }
-
-    DBG_TRACE("destroying slab object '%s'", slabcache_obj->name);
-
-    if (kmem_cache_destroy(slabcache_obj->cache) == 0)
+    if (slabcache_obj->cache)
     {
-        ret = 1;
+        kmem_cache_destroy(slabcache_obj->cache);
         slabcache_obj->cache = NULL;
-    }
-    else
-    {
-        DBG_ERROR("destroying failed");
+        ret = 1;
     }
 
-    DBG_LEAVE("%d", ret);
     return ret;
 }
 
@@ -5190,6 +5222,24 @@
     return 1;
 }
 
+/** \brief Freeze the thread if kernel requested so because of going to suspend
+ *
+ * \return Nonzero if freeze has been performed, zero otherwise
+ *
+ */
+unsigned int kas_try_to_freeze(void)
+{
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,10)
+    return 0;
+#else
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,12)
+    return try_to_freeze(PF_FREEZE);
+#else
+    return try_to_freeze();
+#endif
+#endif
+}
+
 /** \brief Wait for the event
  *
  * If event is already signalled, return right away.
