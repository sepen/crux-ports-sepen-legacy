Index: xfburn/xfburn-burn-data-cd-composition-dialog.c
===================================================================
--- xfburn/xfburn-burn-data-cd-composition-dialog.c	(.../trunk)	(révision 1)
+++ xfburn/xfburn-burn-data-cd-composition-dialog.c	(.../branches/libburnia-updates)	(révision 5)
@@ -44,7 +44,7 @@
 
 typedef struct
 {
-  struct iso_volset * volume_set;
+  IsoImage *image;
 
   GtkWidget *frame_device;
   GtkWidget *device_box;
@@ -60,7 +60,7 @@
 
 enum {
   PROP_0,
-  PROP_VOLUME_SET,
+  PROP_IMAGE
 };
 
 /* prototypes */
@@ -116,8 +116,8 @@
   object_class->set_property = xfburn_burn_data_cd_composition_dialog_set_property;
 
   /* properties */
-  g_object_class_install_property (object_class, PROP_VOLUME_SET,
-				   g_param_spec_pointer ("volume-set", "Volume Set", "Volume Set", G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE));
+  g_object_class_install_property (object_class, PROP_IMAGE,
+				   g_param_spec_pointer ("image", "Image", "Image", G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE));
 }
 
 static void
@@ -225,8 +225,8 @@
   XfburnBurnDataCdCompositionDialogPrivate *priv = XFBURN_BURN_DATA_CD_COMPOSITION_DIALOG_GET_PRIVATE (object);
 
   switch (prop_id) {
-  case PROP_VOLUME_SET:
-    g_value_set_pointer (value, priv->volume_set);
+  case PROP_IMAGE:
+    g_value_set_pointer (value, priv->image);
     break;
   default:
     G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -240,8 +240,8 @@
   XfburnBurnDataCdCompositionDialogPrivate *priv = XFBURN_BURN_DATA_CD_COMPOSITION_DIALOG_GET_PRIVATE (object);
 
   switch (prop_id) {
-  case PROP_VOLUME_SET:
-    priv->volume_set = g_value_get_pointer (value);
+  case PROP_IMAGE:
+    priv->image = g_value_get_pointer (value);
     break;
   default:
     G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -254,7 +254,7 @@
 {
   XfburnBurnDataCdCompositionDialogPrivate *priv = XFBURN_BURN_DATA_CD_COMPOSITION_DIALOG_GET_PRIVATE (object);
 
-  iso_volset_free (priv->volume_set);
+  iso_image_unref (priv->image);
 
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
@@ -315,7 +315,8 @@
   xfburn_progress_dialog_set_status_with_text (XFBURN_PROGRESS_DIALOG (dialog_progress), XFBURN_PROGRESS_DIALOG_STATUS_RUNNING, _("Writing ISO..."));
 
   size = (glong) params->src->get_size (params->src);
-  while (params->src->read (params->src, buf, 2048) == 2048) {
+  /* FIXME: is size really always 2048? */
+  while (params->src->read_xt (params->src, buf, 2048) == 2048) {
     if (write (fd, buf, 2048) < 2048) {
       /* an error occured while writing */
       gchar err[256];
@@ -545,19 +546,20 @@
     GtkWidget *dialog_progress;
 
     struct burn_source * src = NULL;
-    struct ecma119_source_opts src_opts = {};
+    IsoWriteOpts *write_opts;
 
-    src_opts.volnum = 0;
-    src_opts.level = 2;
-    src_opts.flags = ECMA119_JOLIET;
+    /* Sets profile 2 [distribution] */
+    iso_write_opts_new (&write_opts, 2);
 
-    src = iso_source_new_ecma119 (priv->volume_set, &src_opts);
-    if (src == NULL) {
+    if (iso_image_create_burn_source (priv->image, write_opts, &src) < 0) {
       /* could not create source */
       xfce_err (_("Could not create ISO source structure"));
       return;
     }
 
+    /* iso_image_create_burn_source copies the data it needs */
+    iso_write_opts_free (write_opts);
+
     dialog_progress = xfburn_progress_dialog_new (GTK_WINDOW (dialog));
     gtk_window_set_transient_for (GTK_WINDOW (dialog_progress), gtk_window_get_transient_for (GTK_WINDOW (dialog)));
     gtk_widget_hide (GTK_WIDGET (dialog));
@@ -601,11 +603,11 @@
 
 /* public */
 GtkWidget *
-xfburn_burn_data_cd_composition_dialog_new (struct iso_volset * volume_set)
+xfburn_burn_data_cd_composition_dialog_new (IsoImage *image)
 {
   XfburnBurnDataCdCompositionDialog *obj;
 
-  obj = XFBURN_BURN_DATA_CD_COMPOSITION_DIALOG (g_object_new (XFBURN_TYPE_BURN_DATA_CD_COMPOSITION_DIALOG, "volume-set", volume_set, NULL));
+  obj = XFBURN_BURN_DATA_CD_COMPOSITION_DIALOG (g_object_new (XFBURN_TYPE_BURN_DATA_CD_COMPOSITION_DIALOG, "image", image, NULL));
   
   return GTK_WIDGET (obj);
 }
Index: xfburn/xfburn-burn-data-cd-composition-dialog.h
===================================================================
--- xfburn/xfburn-burn-data-cd-composition-dialog.h	(.../trunk)	(révision 1)
+++ xfburn/xfburn-burn-data-cd-composition-dialog.h	(.../branches/libburnia-updates)	(révision 5)
@@ -50,7 +50,7 @@
 
 GtkType xfburn_burn_data_cd_composition_dialog_get_type ();
 
-GtkWidget *xfburn_burn_data_cd_composition_dialog_new (struct iso_volset * volume_set);
+GtkWidget *xfburn_burn_data_cd_composition_dialog_new (IsoImage *image);
 
 G_END_DECLS
 #endif /* XFBURN_BURN_DATA_CD_COMPOSITION_DIALOG_H */
Index: xfburn/xfburn-burn-data-dvd-composition-dialog.c
===================================================================
--- xfburn/xfburn-burn-data-dvd-composition-dialog.c	(.../trunk)	(révision 1)
+++ xfburn/xfburn-burn-data-dvd-composition-dialog.c	(.../branches/libburnia-updates)	(révision 5)
@@ -17,6 +17,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+#if 0
 #ifdef	HAVE_CONFIG_H
 #include <config.h>
 #endif /* !HAVE_CONFIG_H */
@@ -601,3 +602,4 @@
   
   return GTK_WIDGET (obj);
 }
+#endif
Index: xfburn/xfburn-burn-data-dvd-composition-dialog.h
===================================================================
--- xfburn/xfburn-burn-data-dvd-composition-dialog.h	(.../trunk)	(révision 1)
+++ xfburn/xfburn-burn-data-dvd-composition-dialog.h	(.../branches/libburnia-updates)	(révision 5)
@@ -17,6 +17,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+#if 0
 #ifndef __XFBURN_BURN_DATA_DVD_COMPOSITION_DIALOG_H__
 #define __XFBURN_BURN_DATA_DVD_COMPOSITION_DIALOG_H__
 
@@ -54,3 +55,4 @@
 
 G_END_DECLS
 #endif /* XFBURN_BURN_DATA_DVD_COMPOSITION_DIALOG_H */
+#endif
Index: xfburn/xfburn-data-composition.c
===================================================================
--- xfburn/xfburn-data-composition.c	(.../trunk)	(révision 1)
+++ xfburn/xfburn-data-composition.c	(.../branches/libburnia-updates)	(révision 5)
@@ -53,7 +53,7 @@
 
 #include "xfburn-composition.h"
 #include "xfburn-burn-data-cd-composition-dialog.h"
-#include "xfburn-burn-data-dvd-composition-dialog.h"
+//#include "xfburn-burn-data-dvd-composition-dialog.h"
 #include "xfburn-data-disc-usage.h"
 #include "xfburn-main-window.h"
 #include "xfburn-utils.h"
@@ -95,7 +95,7 @@
                                             GtkTreeViewDropPosition position);
 static gboolean add_file_to_list (XfburnDataComposition * dc, GtkTreeModel * model, const gchar * path, GtkTreeIter * iter,
                                   GtkTreeIter * insertion, GtkTreeViewDropPosition position);
-static struct iso_volume * generate_iso_volume (XfburnDataComposition * dc);
+static IsoImage * generate_iso_image (XfburnDataComposition * dc);
                                   
 enum
 {
@@ -422,16 +422,21 @@
 {
   XfburnMainWindow *mainwin = xfburn_main_window_get_instance ();
   GtkWidget *dialog = NULL;
-  struct iso_volume *volume = NULL;
+  IsoImage *image = NULL;
 
-  volume = generate_iso_volume (XFBURN_DATA_COMPOSITION (dc));
+  if (!iso_init()) {
+    g_critical ("Could not initialize libisofs!");
+    return;
+  }
+
+  image = generate_iso_image (XFBURN_DATA_COMPOSITION (dc));
   
   switch (xfburn_data_disc_usage_get_disc_type (du)) {
   case CD_DISC:
-    dialog = xfburn_burn_data_cd_composition_dialog_new (iso_volset_new(volume, "VOLSETID"));
+    dialog = xfburn_burn_data_cd_composition_dialog_new (image);
     break;
   case DVD_DISC:
-    dialog = xfburn_burn_data_dvd_composition_dialog_new (iso_volset_new(volume, "VOLSETID"));
+    //dialog = xfburn_burn_data_dvd_composition_dialog_new (image);
     break;
   }
 
@@ -1440,54 +1445,74 @@
 }
 
 static void
-fill_volume_with_composition (GtkTreeModel *model, struct iso_tree_node_dir * parent, GtkTreeIter *iter)
+fill_image_with_composition (GtkTreeModel *model, IsoImage *image, IsoDir * parent, GtkTreeIter *iter)
 {
   do {
       DataCompositionEntryType type;
       gchar *name = NULL;
       gchar *src = NULL;
+      IsoNode *node = NULL;
+      IsoDir *dir = NULL;
+      int r;
       
-      struct iso_tree_node_dir *node_dir = NULL;
-
       gtk_tree_model_get (model, iter, DATA_COMPOSITION_COLUMN_TYPE, &type,
 			  DATA_COMPOSITION_COLUMN_CONTENT, &name, DATA_COMPOSITION_COLUMN_PATH, &src, -1);
 
-      if (type == DATA_COMPOSITION_TYPE_DIRECTORY) {
-	node_dir = iso_tree_add_dir (parent, name);
-      } else {
-	struct iso_tree_node *node = NULL;
+      if (type == DATA_COMPOSITION_TYPE_DIRECTORY)
+        r = iso_tree_add_new_dir (parent, name, &dir);
+      else
+        r = iso_tree_add_node (image, parent, src, &node);
 
-	node = iso_tree_add_node (parent, src);
-	iso_tree_node_set_name (node, name);
+      if (r < 0) {
+        if (r == ISO_NULL_POINTER)
+          g_error ("Failed adding %s as a node to the image: null pointer!", src);
+        else if (r == ISO_NODE_NAME_NOT_UNIQUE)
+          g_error ("Failed adding %s as a node to the image: node name not unique!", src);
+        /* else if (r == ISO_MEM_ERROR)
+          g_error ("Failed adding %s as a node to the image: memory error!", src); */
+        else
+          g_error ("Failed adding %s as a node to the image: code %d!", src, r);
       }
+
+      /* FIXME: do we need to call iso_node_ref on node? Probably not... */
+      if (type != DATA_COMPOSITION_TYPE_DIRECTORY)
+        iso_node_set_name (node, name);
+
       g_free (name);
       g_free (src);
 
       if (type == DATA_COMPOSITION_TYPE_DIRECTORY && gtk_tree_model_iter_has_child (model, iter)) {
 	GtkTreeIter child;
 
+        /* FIXME: this should not cause a sigfault... 
+        if (iso_node_get_type(node) != LIBISO_DIR)
+            g_error ("Expected %s to be a directory, but it isn't...\n", src);
+        */
+
 	gtk_tree_model_iter_children (model, &child, iter);
-	fill_volume_with_composition (model, node_dir, &child);
+	fill_image_with_composition (model, image, dir, &child);
       }
   } while (gtk_tree_model_iter_next (model, iter));
 }
 
-static struct iso_volume *
-generate_iso_volume (XfburnDataComposition * dc)
+static IsoImage *
+generate_iso_image (XfburnDataComposition * dc)
 {
   XfburnDataCompositionPrivate *priv = XFBURN_DATA_COMPOSITION_GET_PRIVATE (dc);
-  struct iso_volume *volume = NULL;
+  IsoImage *image = NULL;
   GtkTreeModel *model;
   GtkTreeIter iter;
 
-  volume = iso_volume_new (gtk_entry_get_text (GTK_ENTRY (priv->entry_volume_name)), "Xfburn", "Xfburn");
+  iso_image_new (gtk_entry_get_text (GTK_ENTRY (priv->entry_volume_name)), &image);
+  iso_image_set_application_id (image, "Xfburn");
+  iso_image_set_data_preparer_id (image, "Xfburn");
 
   model = gtk_tree_view_get_model (GTK_TREE_VIEW (priv->content));
   if (gtk_tree_model_get_iter_first (model, &iter)) {
-    fill_volume_with_composition (model, iso_volume_get_root (volume), &iter);
+    fill_image_with_composition (model, image, iso_image_get_root (image), &iter);
   }
 
-  return volume;
+  return image;
 }
 
 /****************/
